<h3>Quick CRUD decentralized application starter template setup and modifications</h3>

There are some pre-requisites to complete this chapter. Please review [7. Installing Solana on a Local Dev Machine](7.%20Installing%20Solana%20on%20a%20Local%20Dev%20Machine.md) and [8. Creating the Voting Dapp](./8.%20Creating%20the%20Voting%20Dapp.md) if this is the first time you are creating a Solana Anchor project.

<span style="color: orange;">1.</span>

Enter the following command inside your terminal to generate a scaffold Fullstack Anchor program:

```bash
npx create-solana-dapp
```

This scaffold has your Anchor program that is a counter program and is already connected to a Frontend for you using NextJS and Tailwind.

Follow the instruction provided in the prompts.

- Make `crud-dapp` the value of your project name. Please note that in the bootcamp's video, a different name was used - `crud-app-2`. This guidebook named the project as `crud-dapp`.

- Select a preset for your frontend. Choose the default option which is `Next.js`.

- Choose `next-tailwind-counter (Next.js + Tailwind CSS + Anchor Counter Example)` as your template if that option is available for you.

- Select a UI library. Choose `Tailwind`.

- Select an Anchor template. Choose `Anchor Counter program with tests`.

- Open the generated scaffold, check your `anchor/programs/Cargo.toml` file and verify that your `anchor_lang` dependency is set to 0.30.1.

- You may have to make changes to some folders whose name doesn't match the correct one - `crud-dapp`. If you notice any folder that says `counter` instead of our desired `crud-dapp` name, please change it, however, this is now a rare occurrence.

<br/>

<span style="color: orange;">2.</span>

#### Prepare your project to start afresh

We need to get rid of the counter program that comes with our template. Let use make the neccessary changes to our `anchor/programs/src/lib.rs` code. Make sure that your `lib.rs` looks like this:

```rs
#![allow(clippy::result_large_err)]

use anchor_lang::prelude::*;

declare_id!("coUnmi3oBUtwtd9fjeAvSsJssXh5A5xyPbhpewyzRVF");

#[program]
pub mod cruddapp {
    use super::*;

  //
}

```

Please note that the string value of `declare_id!("")` in your `lib.rs` will be automatically generated for you when you initialize a new dapp project using the Anchor counter program scaffold. It would update every time you `$ anchor build` your project. It is the public key that is going to be the program ID of the Anchor program that you deploy Onchain.

<br/>

<span style="color: orange;">3.</span>

#### Let's define our program account to provide a program state for us to hold all of our data

Please note that smart contracts on Solana are stateless, however, we can use the `#[account]` macro from Anchor inside our program to hold all our program data. Let's call our program state's data structure `JournalEntryState`.

```rs
#![allow(clippy::result_large_err)]

use anchor_lang::prelude::*;

declare_id!("coUnmi3oBUtwtd9fjeAvSsJssXh5A5xyPbhpewyzRVF");

#[program]
pub mod cruddapp {
   use super::*;
}
```

We are creating a journal here because that is a very basic example of a CRUD app. In a journal, you want to create journal entries, you want to be able to update them if you need too and be able to delete them if you need to. Our Journal-Dapp is a very basic journal entry app.

We want to know the owner of our journal, the title of the journal, its journal entry or messsage so we can save that;

```rs
/*
  lib.rs
*/

#![allow(clippy::result_large_err)]

use anchor_lang::prelude::*;

declare_id!("coUnmi3oBUtwtd9fjeAvSsJssXh5A5xyPbhpewyzRVF");

#[program]
pub mod cruddapp {
    use super::*;
}

#[account]
#[derive(InitSpace)]
pub struct JournalEntryState {
  pub owner: Pubkey,
  #[max_len(50)]
  pub title: String,
  #[max-len(50)]
  pub message: String,
}
```

Note that anytime we store data Onchain, we have to pay rent for the storage of such data, and how much rent we pay for storage all depends on the size of the data being stored. The `#[derive(InitSpace)]` macro helps us get an automatic calculation of how much storage is needed to store our `#[account]` program data data-structure.

<br/>

<span style="color: orange;">4.</span>

#### Create

We need an instruction to initiailize a journal entry account. Let's create both the `Accounts` Context and instruction function to create a new journal entry.

The context macro is used to define a struct that encapsulates all the `accounts` that will be passed through a given instruction function. That encapsulating struct is going to be used to create a new journal entry that has its own 'JournalEntryState' (owner, title, and message).

```rs
/*
  lib.rs
*/

// imports
...

// declare_id!("")
...

#[program]
pub mod cruddapp {
    use super::*;

    pub fn create_journal_entry(ctx: Context<CreateEntry>, title: String) -> Result<()> {
        //...
    }
}

#[derive(Accounts)]
#[instruction(title: String)]
pub struct CreateEntry<'info> {
  #[account(
    init,
    seeds = [title.as_bytes(), owner.key().as_ref()],
    bump,
    space = 8 + JournalEntryState::INIT_SPACE,
    payer = owner
  )]
  pub journal_entry: Account<'info, JournalEntryState>,
}

#[account]
#[derive(InitSpace)]
pub struct JournalEntryState {
    // owner
    ...
    // title
    ...
    // message
    ...
}
```

Our `CreateEntry` `Accounts`-Context data structure will define all the `accounts` that are going to be passed through the given instruction that you're writing. These accounts are the `JounalEntryState` account.

We also added constraints on one each the accounts that passes through the journal creation instruction for how we want to handle the handle the creation instruction. We did this by specifying parameters inside an `#[account]`.

- The `init` constraint specifies that we create a new account each time there is in instruction to create a new journal entry.

- We specified the PDA of the account using the `seeds`. There is about infinit ways that you can define a PDA for an account. Here, in our account case, possibly the best way to define a PDA is to specify the owner & another parameter because we want to know who each journal entry belongs to, so, having the owner connected to the PDA is a really easy way to derive that. If we just had the owner, the owner wouldn't be able to create more than one entry On-Chain - we needed to add another parameter to allow them to create more than one entry - `seeds = [title.as_bytes(), owner.key().as_ref()]`. The `title` variable used as part of the seeds come from our instruction handler function `create_journal_entry`, and `title` is being pulled inside our `CreateEntry`-`Account`-Context via `#[instruction(variable_goes_here)]`, as in, `#[instruction(title: String)]`.

- Anytime you define a `seed` constaint, you have to specify `bump` too which is what we did.

- Since we are initiializing an account, we have to be able to calculate the `space` that the `#[account]` is going to take up On-Chain. This is needed so we can know how much rent that we have to pay. Note that whenever you are calculating `space`, you always have to start with the value `8` which is the Anchor Descriminator size. In our case its the addition of the anchor descriminator and JournalEntryState::INIT_SPACE - `8 + JournalEntryState::INIT_SPACE`.

- Lastly, we specifed who is going to pay the rent - the `ownner`. You'll see who the owner is below.

Next, we specify the `owner` which is simply the person signing the journal creation transaction:

```rs
/*
  lib.rs
*/

// imports
...

// declare_id!("")
...

#[program]
pub mod cruddapp {
    use super::*;

    pub fn create_journal_entry(ctx: Context<CreateEntry>, title: String) -> Result<()> {
        //...
    }
}

#[derive(Accounts)]
#[instruction(title: String)]
pub struct CreateEntry<'info> {
  #[account(
    // init
    ...
    // seeds
    ...
    // bump
    ...
    // space
    ...
    // payer
    ...
  )]
  //pub journal_entry
  ...

  #[account(mut)]
  pub owner: Signer<'info>,

  //
}

#[account]
#[derive(InitSpace)]
pub struct JournalEntryState {
    // owner
    ...
    // title
    ...
    // message
    ...
}
```

- The `owner` had to be set to `mut` because in Rust all variables are immutable by default, however, our `owner` is going to be changing the state of its `Account` when it pays for a transaction, therefore, it has to be mutable.

Lastly, we need to define the System Program.

```rs
/*
  lib.rs
*/

// imports
...

// declare_id!("")
...

#[program]
pub mod cruddapp {
    use super::*;

    pub fn create_journal_entry(ctx: Context<CreateEntry>, title: String) -> Result<()> {
        //...
    }
}

#[derive(Accounts)]
#[instruction(title: String)]
pub struct CreateEntry<'info> {
  #[account(t
    // init
    ...
    // seeds
    ...
    // bump
    ...
    // space
    ...
    // payer
    ...
  )]
  // pub journal_entry
  ...

  #[account(mut)]
  // pub owner
  ...

  pub system_program: Program<'info, System>
}

#[account]
#[derive(InitSpace)]
pub struct JournalEntryState {
    // owner
    ...
    // title
    ...
    // message
    ...
}
```
